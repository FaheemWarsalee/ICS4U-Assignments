Faheem:

Selection: Switch case is used to determine which grid needs to be shown lines 677-724. if else statements are used
Repetition: do whiles are used to generate random numbers so that they from 0-8 but never including 6 as seen on lines 1188-1192 for loops are used to initialize arrays of objects as seen on lines 1185-1196 where the all the enemies in the array are initialized to a random location on the map
Methods: void Methods are used to display certain grids as seen on lines 907-916 the method shows the grid on the screen whenever it is called on. return methods were used to return pertinent information back to other methods such as the gridLoc() method that returns an integer that represents the grid location of the player so that the program can figure out which grid to show. overloaded methods in the rectangle class with the show method on lines 103-119 the show method is overloaded so that when parameters are sent the colour of the rectangle calling the method changes
Inheritance and encapsulation:
Recursion: recursion is shown as a menu option that allows you to choose which recursive fractal you would like to see mine or amrew's.
Searches: Sequential search is used when determining if the attacking rectangle of the player is hitting an enemy by searching through the entire array of enemies until the an enemy is found at the same location of the players attack as shown on lines 833-856
Arrays (1-D and Multi-dimensional Arrays and Object Arrays): a multidimensional object array is created and initialized for the grid. instantiated array on line 15. the objects are initialized with a for loop on lines 371-380
File I/O: File reading and writing is used for the saveGame state that saves the players location and the grid location of the map so that when the player presses o it reads the data from the file and loads it into the game as seen on lines 990-1055
Error Handling: try catches were used in places where errors could be found and so they would be handled by the program and not cause the program to crash and produce red code. an instance where such occurs is on lines 993 to 1007 where a try catch is used to read a file but if the file doesn't exist, it creates the file and proceeds as normal instead of crashing the program
Commenting/Documentation: pre&post comments for all methods, all algorithms, procedures etc are detailed with comments about how they work and what they do and their purpose
Incorporate Creativity: The game consists of an original map to explore, the map does not simply stay static but moves when the player reaches the borders of the first map thus allowing for exploration. there are plenty of enemies and obstacles to run into and fights to be had.


A1: arithmetic operations are used when changing the players health, enemies health players position etc. as seen on lines 841 in the client code and lines 46-58 in the Char class. Integer division is used on line 740 for example where division is used to go from pixel locations to a grid location. as seen on lines 1039-1047 all the data read from the file is parsed from a string into either a float or intergers. non-numeric comparisons are made when checking to see if the space around the player is an obstacle or enemy as seen on line 782, 787 for example.the player is prevented from going out of bounds of the array by checking the limitations of the map on line 758 for example. the enemies one dimensional array is used to create alot of enemies simply and effectively by traversing the array with a for loop and creating all enemies within the forloop instead of one by one. using forloops again to traverse the arrays quickly to find enemies at certain locations. these can be found on lines 806-816 for example.
A2: Classes are made and some classes inherit other classes through a hierarchy. Char, Enemy and obstacle for example all inherit from rectangle and allows for easy and seamless comparison between all the common fields of the rectangle.
A3: for Loops are used to initialize arrays of objects for example as seen on lines 371-380 when the 3d grid is made and initalized to hold rectangles. Algorithms such as showGrid() process everything in the array and access the contents of the 3d array to be displayed to the screen
A4: Solved issues with the combat where even though the enemies have been killed and there image has disappeared the player can still interact with where they were and lose hp. fixed this issue by changing the name of the obstacle to nothing after its been killed so the player can walk through. During testing time certain information was displayed to console in an effort to determine and identify problems for testing to see if everything worked as intended. the code follows programming conventions such as camelCase as seen at the beginning of the client code where all fields in memory are made follow the camelCase format and names are short but meaningfull and effective.
B1: Using tomsPlanner and mindomo the project was organised and planned by creating an approximate timeline for time management in tomsplanner. mindomo was used to organize the flow of the game and menus aswell as a log of the daily activities of the group members aswell as a list for the methods and class hierarchy diagrams. when changes were made and tasks were accomplished the ganntChart and mindomo. Mindomo journal notes are organized in a clear fashion. Github was used so that amrew and i could work on separate tasks and keep track of what both people were doing in seperate branches so that no previous work was lost and progress was shown of each person through the branches.
C1: Instead of creating a bunch of variables for left, bottom width height etc for every single rectangle that we were to make in the main code. only one set of those variables needed to be made in Encapsulation was shown in classes such as Rectangle for example where the names of each rectangle are private and when algorithms such as the ones on line 740 for instance, need to access the names of rectangles to check if its an obstacle the accessors for the names are used because the client code cannot access the names directly from the rectangle class because they are private. The equals methods found in the Enemy and booster classes are used as sub programs as they decompose the enemies and booster classes down into their respective Rectangle parts so that comparison between just the rectangles can be compared to determine the objects are equal. Many methods and class methods are reused for the sake of efficiency for example the girdLoc() method is used multiple times throughout the program as its a function that is very versatile. for instance it is used to prevent the player from going beyond the maps limits and to determine an enemies grid location to see if the player has killed or been hit by an enemy.
C2: Algorithms such as those found in the noObstacle() method are particularly effective in solving problems as many tasks could be done one after another by simply reusing methods and algorithms previously made, to solve multiple issues. Such as case 0 on line 735 the methods versatility allows for not only checking obstacles like walls but also enemies around the player which allows the program to take the right course of action according to these checks.
